---
title: "W203 Lab 1: Candidate Dept EDA"
output: html_document
author: 
 - Jon Mease
 - James De La Torre
 - Adam Yang
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

This is the introduction...

### State the research question that motivates your analysis.

### Load your data set into R.

```{r}
DebtRaw = read.csv("../dataset/CandidateDebtDummy.csv", na.strings='#N/A')

# Split off left table
DebtLeft = DebtRaw[, seq(9)]

# Split off right table
DebtRight = DebtRaw[, seq(10, ncol(DebtRaw))]

# Rename DUMMY to office
colnames(DebtRight)[0] <- 'office'

# Keep cases with at least one non-NA entry
DebtRightValid <- DebtRight[rowSums(!is.na(DebtRight)) > 0,]

# Drop duplicates
Debt <- unique(DebtRightValid)
```
### Describe your data set. What types of variables does it contain? How many observations are there?

### Evaluate the data quality. Are there any issues with the data? Explain how you handled these potential issues.

### Explain whether any data processing or preparation is required for your data set.


## Univariate Analysis of Key Variables

Univariate analysis...

### Who are the candidates and how many reports did they file?

```{r}
# Find number of unique reportnumbers
length(unique(DebtLeft$reportnumber))
# Find number of unique cadidate names
length(unique(DebtLeft$filername))
```

On the left half of the data set, we were given 1043 unique report numbers, each of which are associated with a candidate. 
However, there are only 134 unique candidate names in the data set. This suggests that some candidate filed multiple B.3 reports.

To visualize this, we can aggregate the data into a dataframe showing the number of reports filed by each candidate. The summary of this dataframe shows that the candidate that filed the most reports, filed 38 of them while the candidate that filed the fewest reports filed only one. The median of the dataset is 6, while the mean is 7.784 which suggests a strong skew towards the right of the histogram.
```{r}
# Find the number of reports filed by each candidate
RepPerCan <- aggregate(reportnumber ~ filername, DebtLeft, length)
colnames(RepPerCan)[2] <- "NumOfReports"
# Summarize data
summary(RepPerCan$NumOfReports)
```
The summary of this dataframe shows that the candidate that filed the most reports, filed 38 of them while the candidate that filed the fewest reports filed only one. The median of the dataset is 6, while the mean is 7.784 which suggests a strong skew towards the right of the histogram.

Before looking at the histogram, lets take a look at the candidates that filed the most reports. Unfortunately, our dataset does not allow us to view which candidates occured the most debt. However, we can see which ones filed the most debt reports.
```{r}
# Show top 5 candidates that filed the most reports
head(RepPerCan[order(RepPerCan$NumOfReports, decreasing = TRUE),],5)
```

The summary of the dataset suggests that there are many candidates that filed only one report. In fact, 22 candidates filed only 1 report.

```{r}
# How many candidates filed only 1 report?
length(which(RepPerCan$NumOfReports == 1))
```

The figure below is a histogram showing the number of reports filed by each candidate and it does seem that there is a skew to the right. Most candidates filed between 1 and 5 reports and very few filed over 20 reports.

```{r}
# Show histogram showing distribution of the number of reports filed by each candidate.
hist(RepPerCan$NumOfReports, main = "Histogram of the Number of Reports Filed by Each Candidate",
     xlab = "Number of Reports Filed by a Candidate")
axis(1, at = seq(0,40, by = 5))
```

### Which offices are being pursued by the candidates?

To get a sense of how many candidates are applying for each office, we first have to get rid of the duplicate candidates.
```{R}
# Remove reportnumber and keep unique rows
Office <- unique(DebtLeft[-1])
# Find length of rows.
length(Office$filerid)
```

After creating this new dataframe, there are 141 rows instead of the expected 134. By doing a summary of Office$filername, we can see that there are 7 candidates that have more than 1 row. Upon inspection, these 7 candidates have 2 different filerids and sought 2 different offices. An example is shown below. According to the two rows shown below, it looks like David S Frockt was running for State Representative but then switched to State Senator based on the numbering of the filerid. With some quick research, we found that David Frockt was a State Representative in 2010 but was elected as State Senator in the middle of 2011 after the death of Senator Scott White. This special situation would explains the discrepancy with the dataset. 

```{R}
# Show exmaple of duplicate candidate.
Office[Office$filername == "FROCKT DAVID S",]
```

Because when a candidate changes his mind and decides to go for a different office, it still reflects the popularity of both offices. Besides, we do not have to data to determine which of these offices the candidate ended up running for so I will keep these the dataset as 141 rows and not remove any duplicate candidate for the histogram.

```{R}
# Create Dataframe showing the number of candidates running for each office
OfficePopularity <- aggregate(filername ~ office, Office, length)
colnames(OfficePopularity)[2] <- "N"

# Show barplot of results
op <- par(mar = c(10,4,4,2) + 0.1)
barplot(OfficePopularity$N, main = "Number of Candidates Running for Each Office", ylab = "# of Cadidates",
      names.arg=OfficePopularity$office, las = 2, cex.names=0.6)
par(op)
```

### Which party has the most candidates running for office?
Now we will start looking at the data in the second data set (the one with vendor information and debt amount). We have no way of knowing which debt report was filed by which candidate and we know from above that one candidate can file multiple reports. However, assuming that each candidate will have a unique combination of office, legislative dictrict, position, party, and jurisdiction, we can find the rows that are unique for all of these categories and assume each row is a candidate. Now we can plot a bar chart to get a sense of how many cadidates for each party are filing these debt reports.

```{R}
# Only keep Office2, legislativedictrict, position, party, jurisdiction and find unique rows
DebtUnique <- unique(Debt[1:5])
# 
PartyCount <- aggregate(jurisdiction ~ party, DebtUnique, length)
colnames(PartyCount)[2] <- "N"
#
op <- par(mar = c(5,4,4,2) + 0.1)
barplot(PartyCount$N, main = "Number of Candidates from each Party", ylab = "# of Cadidates",
      names.arg=PartyCount$party, las = 2, cex.names=0.6)
par(op)
```
As mentioned before, the two data sets are really different and both are very innacurate. So the only thing we can get out of this bar chart is that there are mostly Democratic Candidates running for offices in Washington State.

### Histogram of the debt amount
```{R}
summary(Debt$amount)
```
Very strong skew to the right.

```{R}
hist(Debt$amount, breaks = seq(0, 20000, by = 100) , main = "Histogram of the Amount of Dollars per Debt Report Filed",
     xlab = "Debt Amount per Report ($)", las = 2)
axis(1, at = seq(0, 20000, by = 1000), las = 2)
```
```{R}
filteredAmount <- Debt[(Debt$amount < 4000),]
hist(filteredAmount$amount, breaks = seq(0, 4000, by = 100) , main = "Histogram of the Amount of Dollars per Debt Report Filed",
     xlab = "Debt Amount per Report ($)", las = 2)
axis(1, at = seq(0, 4000, by = 1000), las = 2)
```
## Analysis of Key Relationships

Key relationships...
### How much money is each party spending?

The first bivariate relationship explored was the total expenditure by political party.  The working debt dataset was grouped by party, and the sum of the dollar amounts for each group was computed.  Figure 10 shows a bar chart with this information.  Expenditures in the dataset were overwhelmingly from Democrats,  accounting for 79% of the total dolalr amount.

```{r}

# sum amount by party
amountbyparty <-aggregate(Debt['amount'], by=list(party=Debt$party), FUN=sum)

#format method, which is necessary for formating in a data.frame   
format.money  <- function(x, ...) {
  paste0("$", formatC(as.numeric(x), format="f", digits=2, big.mark=","))
}
class(amountbyparty$amount) <- c("money",class(amountbyparty$amount))


# sort the list descending, create pareto
amountbyparty <- amountbyparty[order(amountbyparty$amount, decreasing=TRUE),]

# bar plot tutorial https://www.statmethods.net/graphs/bar.html
barplot(amountbyparty$amount, main="Total Expenditures by Political Party", 
  	xlab="Political Party",
  	names.arg=amountbyparty$party,
  	cex.names=1)

# Move on to by pareto subgroup, normalized into percent.

# Maybe I should make a function for bar charts, since I will be making many of them.



```


### Where is the money going?

The next relationship explored was expenditure by expense category.  The dataset's description column provided some categorization of expenses, but since the description field was populated by different people for different reports, there was not much consistency of description values.  Out of 194 records, there were 105 unique values in the description column.  Another column in the dataset, code, was supposed to provide a more generalized categorization of expenses.  However, this field was populated in only 94 of 194 records and only encompassed 20% of the grand total of all expenses in the dataset ($55,326.09 out of $269,191.70).

Since the description data were too granular, and since the code data were too sparse, a new column, coarsedescription, was generated by manually examining the values in the original description column and assigning more general, coarse labels to them.  For example, there were 23 description values of the form "TREASURY " + month.  These were all assigned into coarsecategory "TREASURY".  Similarly, there were several descriptions values that indicated they were related to consulting, so these were assigned coarsedescription "CONSULTING".  In some cases where the nature of an expense was not immediately clear, a quick bit of web searching for the type of business in the vendorname column helped to determine a reasonable value for coarsedescription.  In those cases, an explanation of the reasoning for selecting the value of coarse category is provided in a comments column.  There is the possibility that some description values did not get mapped into their optimum coarsedescription category, but the author is reasonably confident that the mapping is sensible.  The 106 unique description values were mapped to 23 coarsedescription values.  For a complete listing of the translation from description to coarsedescription, see Appendix A.

A pareto of total expenditure by coarsedescription is shown in Figure 10.  The total for a given coarsedescription is computed simply by summing the values in the amount column for all records having that coarsedescription.

```{r}
desc_to_coarsedesc = read.csv("../dataset/description_to_coarsedescription.csv", na.strings='#N/A')
# we need to merge coarsedescription into Debt by description
Debt2=merge(Debt,desc_to_coarsedesc[c('description','coarsedescription')])

# Put 0 for position when there is no value
Debt2$position[is.na(Debt2$position)] <- 0
Debt2$legislativedistrict[is.na(Debt2$legislativedistrict)] <- 0

# sum amount by coarsedescription
amountbycoarsedesc <-aggregate(Debt2['amount'], by=list(coarsedescription=Debt2$coarsedescription), FUN=sum)

#format method, which is necessary for formating in a data.frame   
format.money  <- function(x, ...) {
  paste0("$", formatC(as.numeric(x), format="f", digits=2, big.mark=","))
}
class(amountbycoarsedesc$amount) <- c("money",class(amountbycoarsedesc$amount))


# sort the list descending, create pareto
amountbycoarsedesc <- amountbycoarsedesc[order(amountbycoarsedesc$amount, decreasing=TRUE),]
#print(amountbycoarsedesc)

nbars=14
topn=amountbycoarsedesc[1:nbars,]
?barplot
# bar plot tutorial https://www.statmethods.net/graphs/bar.html
barplot(topn$amount, main="Total Expenditures by Coarse Description",
        sub=paste(c("(Top", nbars, "shown)"), collapse = " "),
  	xlab="Coarse Description",
  	names.arg=topn$coarsedescription,
  	cex.names=0.65)

# Move on to by pareto subgroup, normalized into percent.

# Maybe I should make a function for bar charts, since I will be making many of them.



```

### Do the parties spend their money differently?

The expenditures by category can be broken down by political party to see differences in how Republicans and Democrats allocate their expenses.  Since the total expenditures were so different between the parties, rather than look at the raw dollar amounts, the data were normalized to fraction of total expenditure for a given party.  Since there were only $102.88 in expenditures for Independent candidates (0.04% of total), all spent in a single coarse category (Mailing Services), Indpendent party data were excluded from this specific analysis.

Figure 12 shows a pareto of fraction of party total expenditure by coarse description, by party.  The data reveal that Democrats and Non-partisan candidates spent a greater fraction of money on consulting than the Republicans, while Republicans spent a greater fraction on credit card payments and telecom expenses.  Unfortunately, there is no visibility into what purchases were made using the credit cards (the raw description column just named the credit card (e.g., AMEX), so it provides no additional information, either.)

```{r}

# Rename "subject" column to "N"
names(amountbyparty)[names(amountbyparty)=="amount"] <- "totalamountbyparty"

#rollup debt2 by coarsedesc and party
expense_by_coarsedesc_by_party <-aggregate(Debt2['amount'],                                         by=list(coarsedescription=Debt2$coarsedescription, party=Debt2$party), FUN=sum)


#merge totalamount into expense_by_coarsedesc_by_party
frac_by_coarsedesc_by_party <- merge(expense_by_coarsedesc_by_party,amountbyparty)
# compute fraction
frac_by_coarsedesc_by_party$fractionofpartytotal <- frac_by_coarsedesc_by_party$amount / frac_by_coarsedesc_by_party$totalamountbyparty

# drop independents
frac_by_coarsedesc_by_party <- frac_by_coarsedesc_by_party[frac_by_coarsedesc_by_party$party != "INDEPENDENT", ]

# get max frac by coarsedescription (across parties)
maxfrac_by_coarsedesc <-aggregate(frac_by_coarsedesc_by_party['fractionofpartytotal'],
                                           by=list(coarsedescription=frac_by_coarsedesc_by_party$coarsedescription), FUN=max)

# Rename "fractionofpartytotal" column to "maxfracofpartytotal"
names(maxfrac_by_coarsedesc)[names(maxfrac_by_coarsedesc)=="fractionofpartytotal"] <- "maxfracofpartytotal"

#merge maxfrac into frac_by_coarsedesc_by_party
frac_by_coarsedesc_by_party2=merge(frac_by_coarsedesc_by_party,maxfrac_by_coarsedesc)


# assign part number to put nonpartisan last
frac_by_coarsedesc_by_party2$partynumber<-ifelse(frac_by_coarsedesc_by_party2$party=="DEMOCRAT",1,
		ifelse(frac_by_coarsedesc_by_party2$party=="REPUBLICAN",2,3
		))

#Now, sort the df by maxfracofpartytotal desc, then by partynumber
frac_by_coarsedesc_by_party2 <- frac_by_coarsedesc_by_party2[order(-frac_by_coarsedesc_by_party2$maxfracofpartytotal,
                                                                   frac_by_coarsedesc_by_party2$partynumber),]

# Now we can finally make a grouped pareto!
frac_by_coarsedesc_by_party2$barlabels <- ""
frac_by_coarsedesc_by_party2$barlabels <- frac_by_coarsedesc_by_party2$barlabels <-

  
# Trick Make labels which are non blank only when row mod 3 =2
x<-1:nrow(frac_by_coarsedesc_by_party2)
y <- x%%3==2

cd=frac_by_coarsedesc_by_party2$coarsedescription
frac_by_coarsedesc_by_party2$barlabels <- with(frac_by_coarsedesc_by_party2, ifelse(y,cd,"" ) )

cd <- frac_by_coarsedesc_by_party2$coarsedescription
frac_by_coarsedesc_by_party2$barlabels <- ifelse(y,frac_by_coarsedesc_by_party2$coarsedescription,"" )


# now make a sidebyside bar chart
barplot(frac_by_coarsedesc_by_party2$fractionofpartytotal, main="Fractional Expenditures by Coarse Description, by Party",
        xlab="Coarse Description", col=c("blue","red","green"),
        legend = c("Democrat","Republican","Non Partisan"), beside=TRUE, names.arg=frac_by_coarsedesc_by_party2$coarsedescription, las=2)

```

### For Which Types of Offices is the Most Money Spent?

An analysis of amount of expenditure by office was performed by summing the amounts spent by unique value of the office2 column (the office column from the right half of the dataset).  However, since the number of offices of a given type varied (there are more state representatives than state senators or governors), and since the number of candidates varied by office type, the amounts were divided by the number of unique combinations of legislativedistrict, position, and party within each office2 value.  The intent of this was to normalize the amounts to a "per campaign" value.  For example, there were 39 unique candidates for state representative.  In Washington, there are two state representatives per legislative district, and the position column designates which of these two slots a row belongs to.  The party column provides another level of granularity for a given line item.  A pareto of expenditures per campaign by office is shown in Figure 13.  Note that since the dataset does not have a unique candidate identifier, such as a number or registration ID, multiple candidates of the same party with expenditures for the same office and position would be treated as a single candidate.

The pareto shows that the race for governor had the greatest expenditure per candidate.  Two other statewide offices, treasurer and attorney general, showed the next highest expenditures per candidate.

```{r}
# get sum of amount by DUMMY
#sumbyoffice <- aggregate(Debt2['amount'],
#by=list(office=Debt2$DUMMY), FUN=sum)

# get sum(amount) and n rows by unique value of DUMMY, legislativedistrict, position, and party,
# and jurisdictiontype (in case I summarize by that later).
sumbycand <- aggregate(Debt2['amount'],
by=list(office=Debt2$DUMMY, legislativedistrict=Debt2$legislativedistrict, position=Debt2$position, party=Debt2$party, jurisdictiontype=Debt2$jurisdictiontype), FUN=sum)


# now sum the amounts in sumbycand and count rows by office
sumbyoffice <- aggregate(sumbycand['amount'], by=list(office=sumbycand$office), FUN=sum)
countbyoffice <- aggregate(sumbycand['position'], by=list(office=sumbycand$office), FUN=length)

# Rename cols
names(sumbyoffice)[names(sumbyoffice)=="amount"] <- "totalamount"
names(countbyoffice)[names(countbyoffice)=="position"] <- "ncandidates"

# merge the sum and count data
amountperjob <- merge(sumbyoffice,countbyoffice)
amountperjob$mean_amount <- amountperjob$totalamount / amountperjob$ncandidates

# sort by mean_amount desc
# sort the list descending, create pareto
amountperjob <- amountperjob[order(amountperjob$mean_amount, decreasing=TRUE),]

# bar plot tutorial https://www.statmethods.net/graphs/bar.html
barplot(amountperjob$mean_amount, main="Expenditure per Candidate by Office", 
  	xlab="Office",
  	names.arg=amountperjob$office,
  	cex.names=1, las=2)


```



## Analysis of Secondary Effects ...

Secondary effects...

## Conclusion
Conclusion...