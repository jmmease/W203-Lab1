---
title: "W203 Lab 1: Candidate Dept EDA"
output: html_document
author: 
 - Jon Mease
 - James De La Torre
 - Adam Yang
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

This is the introduction...

### State the research question that motivates your analysis.

### Load your data set into R.

```{r}
DebtRaw = read.csv("../dataset/CandidateDebtDummy.csv", na.strings='#N/A')

# Split off left table
DebtLeft = DebtRaw[, seq(9)]

# Split off right table
DebtRight = DebtRaw[, seq(10, ncol(DebtRaw))]

# Rename DUMMY to office
colnames(DebtRight)[0] <- 'office'

# Keep cases with at least one non-NA entry
DebtRightValid <- DebtRight[rowSums(!is.na(DebtRight)) > 0,]

# Drop duplicates
Debt <- unique(DebtRightValid)
```
### Describe your data set. What types of variables does it contain? How many observations are there?

### Evaluate the data quality. Are there any issues with the data? Explain how you handled these potential issues.

### Explain whether any data processing or preparation is required for your data set.


## Univariate Analysis of Key Variables

Univariate analysis...

## Analysis of Key Relationships

Key relationships...
### How much money is each party spending?

The first bivariate relationship explored was the total expenditure by political party.  The working debt dataset was grouped by party, and the sum of the dollar amounts for each group was computed.  Figure 10 shows a bar chart with this information.  Expenditures in the dataset were overwhelmingly from Democrats,  accounting for 79% of the total dolalr amount.

```{r}

# sum amount by party
amountbyparty <-aggregate(Debt['amount'], by=list(party=Debt$party), FUN=sum)

#format method, which is necessary for formating in a data.frame   
format.money  <- function(x, ...) {
  paste0("$", formatC(as.numeric(x), format="f", digits=2, big.mark=","))
}
class(amountbyparty$amount) <- c("money",class(amountbyparty$amount))


# sort the list descending, create pareto
amountbyparty <- amountbyparty[order(amountbyparty$amount, decreasing=TRUE),]

# bar plot tutorial https://www.statmethods.net/graphs/bar.html
barplot(amountbyparty$amount, main="Total Expenditures by Political Party", 
  	xlab="Political Party",
  	names.arg=amountbyparty$party,
  	cex.names=1)

# Move on to by pareto subgroup, normalized into percent.

# Maybe I should make a function for bar charts, since I will be making many of them.



```


### Where is the money going?

The next relationship explored was expenditure by expense category.  The dataset's description column provided some categorization of expenses, but since the description field was populated by different people for different reports, there was not much consistency of description values.  Out of 194 records, there were 105 unique values in the description column.  Another column in the dataset, code, was supposed to provide a more generalized categorization of expenses.  However, this field was populated in only 94 of 194 records and only encompassed 20% of the grand total of all expenses in the dataset ($55,326.09 out of $269,191.70).

Since the description data were too granular, and since the code data were too sparse, a new column, coarsedescription, was generated by manually examining the values in the original description column and assigning more general, coarse labels to them.  For example, there were 23 description values of the form "TREASURY " + month.  These were all assigned into coarsecategory "TREASURY".  Similarly, there were several descriptions values that indicated they were related to consulting, so these were assigned coarsedescription "CONSULTING".  In some cases where the nature of an expense was not immediately clear, a quick bit of web searching for the type of business in the vendorname column helped to determine a reasonable value for coarsedescription.  In those cases, an explanation of the reasoning for selecting the value of coarse category is provided in a comments column.  There is the possibility that some description values did not get mapped into their optimum coarsedescription category, but the author is reasonably confident that the mapping is sensible.  The 106 unique description values were mapped to 23 coarsedescription values.  For a complete listing of the translation from description to coarsedescription, see Appendix A.

A pareto of total expenditure by coarsedescription is shown in Figure 10.  The total for a given coarsedescription is computed simply by summing the values in the amount column for all records having that coarsedescription.

```{r}
desc_to_coarsedesc = read.csv("../dataset/description_to_coarsedescription.csv", na.strings='#N/A')
# we need to merge coarsedescription into Debt by description
Debt2=merge(Debt,desc_to_coarsedesc[c('description','coarsedescription')])

# Put 0 for position when there is no value
Debt2$position[is.na(Debt2$position)] <- 0
Debt2$legislativedistrict[is.na(Debt2$legislativedistrict)] <- 0

# sum amount by coarsedescription
amountbycoarsedesc <-aggregate(Debt2['amount'], by=list(coarsedescription=Debt2$coarsedescription), FUN=sum)

#format method, which is necessary for formating in a data.frame   
format.money  <- function(x, ...) {
  paste0("$", formatC(as.numeric(x), format="f", digits=2, big.mark=","))
}
class(amountbycoarsedesc$amount) <- c("money",class(amountbycoarsedesc$amount))


# sort the list descending, create pareto
amountbycoarsedesc <- amountbycoarsedesc[order(amountbycoarsedesc$amount, decreasing=TRUE),]
#print(amountbycoarsedesc)

nbars=14
topn=amountbycoarsedesc[1:nbars,]
?barplot
# bar plot tutorial https://www.statmethods.net/graphs/bar.html
barplot(topn$amount, main="Total Expenditures by Coarse Description",
        sub=paste(c("(Top", nbars, "shown)"), collapse = " "),
  	xlab="Coarse Description",
  	names.arg=topn$coarsedescription,
  	cex.names=0.65)

# Move on to by pareto subgroup, normalized into percent.

# Maybe I should make a function for bar charts, since I will be making many of them.



```

### Do the parties spend their money differently?

The expenditures by category can be broken down by political party to see differences in how Republicans and Democrats allocate their expenses.  Since the total expenditures were so different between the parties, rather than look at the raw dollar amounts, the data were normalized to fraction of total expenditure for a given party.  Since there were only $102.88 in expenditures for Independent candidates (0.04% of total), all spent in a single coarse category (Mailing Services), Indpendent party data were excluded from this specific analysis.

Figure 12 shows a pareto of fraction of party total expenditure by coarse description, by party.  The data reveal that Democrats and Non-partisan candidates spent a greater fraction of money on consulting than the Republicans, while Republicans spent a greater fraction on credit card payments and telecom expenses.  Unfortunately, there is no visibility into what purchases were made using the credit cards (the raw description column just named the credit card (e.g., AMEX), so it provides no additional information, either.)

```{r}

# Rename "subject" column to "N"
names(amountbyparty)[names(amountbyparty)=="amount"] <- "totalamountbyparty"

#rollup debt2 by coarsedesc and party
expense_by_coarsedesc_by_party <-aggregate(Debt2['amount'],                                         by=list(coarsedescription=Debt2$coarsedescription, party=Debt2$party), FUN=sum)


#merge totalamount into expense_by_coarsedesc_by_party
frac_by_coarsedesc_by_party <- merge(expense_by_coarsedesc_by_party,amountbyparty)
# compute fraction
frac_by_coarsedesc_by_party$fractionofpartytotal <- frac_by_coarsedesc_by_party$amount / frac_by_coarsedesc_by_party$totalamountbyparty

# drop independents
frac_by_coarsedesc_by_party <- frac_by_coarsedesc_by_party[frac_by_coarsedesc_by_party$party != "INDEPENDENT", ]

# get max frac by coarsedescription (across parties)
maxfrac_by_coarsedesc <-aggregate(frac_by_coarsedesc_by_party['fractionofpartytotal'],
                                           by=list(coarsedescription=frac_by_coarsedesc_by_party$coarsedescription), FUN=max)

# Rename "fractionofpartytotal" column to "maxfracofpartytotal"
names(maxfrac_by_coarsedesc)[names(maxfrac_by_coarsedesc)=="fractionofpartytotal"] <- "maxfracofpartytotal"

#merge maxfrac into frac_by_coarsedesc_by_party
frac_by_coarsedesc_by_party2=merge(frac_by_coarsedesc_by_party,maxfrac_by_coarsedesc)


# assign part number to put nonpartisan last
frac_by_coarsedesc_by_party2$partynumber<-ifelse(frac_by_coarsedesc_by_party2$party=="DEMOCRAT",1,
		ifelse(frac_by_coarsedesc_by_party2$party=="REPUBLICAN",2,3
		))

#Now, sort the df by maxfracofpartytotal desc, then by partynumber
frac_by_coarsedesc_by_party2 <- frac_by_coarsedesc_by_party2[order(-frac_by_coarsedesc_by_party2$maxfracofpartytotal,
                                                                   frac_by_coarsedesc_by_party2$partynumber),]

# Now we can finally make a grouped pareto!
frac_by_coarsedesc_by_party2$barlabels <- ""
frac_by_coarsedesc_by_party2$barlabels <- frac_by_coarsedesc_by_party2$barlabels <-

  
# Trick Make labels which are non blank only when row mod 3 =2
x<-1:nrow(frac_by_coarsedesc_by_party2)
y <- x%%3==2

cd=frac_by_coarsedesc_by_party2$coarsedescription
frac_by_coarsedesc_by_party2$barlabels <- with(frac_by_coarsedesc_by_party2, ifelse(y,cd,"" ) )

cd <- frac_by_coarsedesc_by_party2$coarsedescription
frac_by_coarsedesc_by_party2$barlabels <- ifelse(y,frac_by_coarsedesc_by_party2$coarsedescription,"" )


# now make a sidebyside bar chart
barplot(frac_by_coarsedesc_by_party2$fractionofpartytotal, main="Fractional Expenditures by Coarse Description, by Party",
        xlab="Coarse Description", col=c("blue","red","green"),
        legend = c("Democrat","Republican","Non Partisan"), beside=TRUE, names.arg=frac_by_coarsedesc_by_party2$coarsedescription, las=2)

```

### For Which Types of Offices is the Most Money Spent?

An analysis of amount of expenditure by office was performed by summing the amounts spent by unique value of the office2 column (the office column from the right half of the dataset).  However, since the number of offices of a given type varied (there are more state representatives than state senators or governors), and since the number of candidates varied by office type, the amounts were divided by the number of unique combinations of legislativedistrict, position, and party within each office2 value.  The intent of this was to normalize the amounts to a "per campaign" value.  For example, there were 39 unique candidates for state representative.  In Washington, there are two state representatives per legislative district, and the position column designates which of these two slots a row belongs to.  The party column provides another level of granularity for a given line item.  A pareto of expenditures per campaign by office is shown in Figure 13.  Note that since the dataset does not have a unique candidate identifier, such as a number or registration ID, multiple candidates of the same party with expenditures for the same office and position would be treated as a single candidate.

The pareto shows that the race for governor had the greatest expenditure per candidate.  Two other statewide offices, treasurer and attorney general, showed the next highest expenditures per candidate.

```{r}
# get sum of amount by DUMMY
#sumbyoffice <- aggregate(Debt2['amount'],
#by=list(office=Debt2$DUMMY), FUN=sum)

# get sum(amount) and n rows by unique value of DUMMY, legislativedistrict, position, and party,
# and jurisdictiontype (in case I summarize by that later).
sumbycand <- aggregate(Debt2['amount'],
by=list(office=Debt2$DUMMY, legislativedistrict=Debt2$legislativedistrict, position=Debt2$position, party=Debt2$party, jurisdictiontype=Debt2$jurisdictiontype), FUN=sum)


# now sum the amounts in sumbycand and count rows by office
sumbyoffice <- aggregate(sumbycand['amount'], by=list(office=sumbycand$office), FUN=sum)
countbyoffice <- aggregate(sumbycand['position'], by=list(office=sumbycand$office), FUN=length)

# Rename cols
names(sumbyoffice)[names(sumbyoffice)=="amount"] <- "totalamount"
names(countbyoffice)[names(countbyoffice)=="position"] <- "ncandidates"

# merge the sum and count data
amountperjob <- merge(sumbyoffice,countbyoffice)
amountperjob$mean_amount <- amountperjob$totalamount / amountperjob$ncandidates

# sort by mean_amount desc
# sort the list descending, create pareto
amountperjob <- amountperjob[order(amountperjob$mean_amount, decreasing=TRUE),]

# bar plot tutorial https://www.statmethods.net/graphs/bar.html
barplot(amountperjob$mean_amount, main="Expenditure per Candidate by Office", 
  	xlab="Office",
  	names.arg=amountperjob$office,
  	cex.names=1, las=2)


```



## Analysis of Secondary Effects ...

Secondary effects...

## Conclusion
Conclusion...